1장, 제목

발표 시작하겠습니다.

안녕하세요 모두의 SSE 발표를 진행하는 김태훈입니다.
저는 아래 닉네임으로 활동하고 있습니다.

2장, 발표 순서

발표는 다음 순서로 진행됩니다.
먼저 SSE는 어떤 기술이고, 무엇을 할 수 있는지, 어떤 사람들에게 유용한지 알아보겠습니다.
두번째로 비슷한 기능을 가진 다른 기술들과 비교하겠습니다.
세번재로 스프링에서 SSE를 지원하는 기술들을 알아겠습니다.
마지막으로 간단한 실습을 진행하겠습니다.

3장, 어떤걸 할 수 있나요, 누구에게 유용한가요

SSE는 서버에서 클라이언트 단방향으로 요청없이 데이터를 전송할 수 있습니다.
서버에서 데이터를 전송하는 특징을 이용해, 실시간 전송이 필요한 기능들을 구현할 수 있습니다.

따라서 댓글을 전송하거나, 알림 발송, 주식 차트 등을 구현해야하는 상황에서 유용합니다.

4장, 왜 굳이 SSE여야 하나요

실시간 데이터 전송을 지원하는 전통적인 방법 2가지 폴링, 롱 폴링에 대해 가볍게 알아보고,
웹소켓, 서비스 워커 등과 SSE를 비교해보겠습니다.

먼저 폴링은 클라이언트에서 일정 주기로, 요청을 전송하여 실시간으로 서버의 데이터를 받아오는 방식이고,
롱 폴링은 클라이언트가 요청을 보내면 응답 데이터가 있을때까지 지연시켰다가 응답하는 방식입니다.

웹소켓, sse 등은 전통적인 폴링, 롱 폴링과 달리 클라이언트의 요청없이 서버에서 데이터를 바로 전송하기 때문에 더 효율적입니다. 

이어어서 웹소켓에 대해 알아보겠습니다.
웹소켓은 처음에는 http를 이용하지만, 이후에는 자체 프로토콜을 이용합니다.
때문에 http의 캐싱이나 압축등과 같은 이점을 활용하지 못하는 단점이 있습니다.

다음으로 서비스 워커는, 생명주기 등이 복잡하여 처음 도입하기에는 망설여집니다.
몇몇 브라우저의 경우, 푸쉬가 발생하면 반드시 사용자에게 이를 표시해야하는 제약이 있습니다.
만약에 사용자에게 알리지 않고 백그라운드에서 필요한 작업인 경우, 적합하지 않을 수 있습니다.

SSE는, http를 그대로 사용할 수 있고, 백그라운드 작업은 물론 sse를 지원하는 기술들이 이미 마련되어 있는 장점이 있습니다.

5장, 스프링에서 SSE를 서포팅하는 기술

스프링 mvc 패키지와 webflux에서 SSE를 지원하고 있습니다.
이 중 에스에스이 이미터(SseEmitter)를 이용해 서버 센트 이벤트를 구현할 수 있습니다.

6장, 실습 순서

실습은 이해를 돕기위해 시나리오 설명, 구성품 소개, 실습 순으로 진행하겠습니다.

7장, 실습 시나리오 설명

본격적으로 실습을 진행하기 전에, 실습에서 시연하게 될 시나리오에 대해 설명드리도록 하겠습니다.
본 발표에서 시현하는 시나리오는 총 2가지입니다.
첫번째 시나리오는 특정 게시글에 유저가 알림 요청을 전송하는 것입니다. 이를 통해 SSE 연결이 수립되었는지 확인하겠습니다.
두번째 시나리오는 해당 게시글에 다른 유저가 댓글 작성하게 되면, 이전에 알림 요청한 유저에게 새로고침없이 새로운 댓글이 보여지는게되는 시나리오입니다.

8장, 실습 구성품 소개

다음으로 레포지토리 안의 구성품에 대해 설명드리도록 하겠습니다.
레포지토리를 클론하시면 루트 디렉토리 안에는 핸즈온 패키지와 프레퍼레이션 패키지 2가지가 보이게 됩니다.
이 중 프레퍼레이션 패키지는 제가 미리 준비해둔 패키지이고, 핸즈온 패키지안의 2개의 클래스는 함께 실습을 진행하며 만들어갈 파일입니다.

다음으로 편의를 위해 미리 작성된 프레페레이션 패키지 안의 코드에 대해 설명드리도록 하겠습니다.
코멘트 클래스는 게시글에 달리는 댓글입니다. 댓글은 쉬운 구현을 위해 작성자나, 제목과 같은 내용은 제거했고, 댓글 내용만 담고 있습니다.
인덱스 컨트롤러는 에이취티엠엘(html) 파일을 받기 위한 컨트롤러입니다. 에이취티엠엘(html)과 자바스크립트(js) 코드는 미리 작성해두었습니다.
커넥션 클래스는 스프링의 에스에스이 이미터(SseEmitter)를 추상화시킨 클래스입니다. 해당 클래스에 대한 내용은 실습에서 알아보도록 하겠습니다.

다음으로 3가지 커넥션 매니저 클래스에 대해 소개시켜 드리겠습니다.
실습 시나리오상 유저가 게시물에 댓글을 작성하고, 게시글에 달린 댓글은 해당 게시글과 연결된 다른 유저에게 보여져야합니다.
때문에 아티클과 연결된 커넥션, 그리고 유저와 연결된 커넥션 2가지를 관리해야되는 포인트가 있습니다.
이를 도와드리고자 아티클 투 커넥션, 탭 투 커넥션 2개의 클래스를 작성했고, 이를 관리하는 커넥션 매니저 클래스를 추가해두었습니다.
이후 실습에서는 커넥션 매니저 클래스의 콜백과 쓰레드 세이프에 대해 설명드리고, 탭 투 커넥션 클래스에서는 타임아웃과 만료시간에 대한 관계를 설명드리도록 하겠습니다.

마지막으로 핸즈온 패키지에 대해 설명드리겠습니다.
핸즈온 패키지 안의 2개 클래스 파일은 이번 실습을 통해 완성하게 될 파일입니다.
코멘트 컨트롤러에서는 SSE 연결 요청과 댓글 전송 요청을 매핑하는 코드를 작성하겠습니다.
코멘트 서비스에서는 각각의 시나리오에 대한 로직을 완성시켜나갈 메인 코드입니다.

[ppt 장표에 구현 중 어려울만한 내용은 미리 코드 스니펫으로 올려두자]

[첫번째 시나리오, 알림 요청]
첫번째 시나리오인 알림 요청 전송하는 기능을 작성해보도록 하겠습니다.
먼저 유저가 게시글에 알림을 걸 수 있도록 컨트롤러의 커넥트 메소드를 작성해보겠습니다.
이때 프로듀스(produces)의 값은 텍스트 이벤트 스트림(TEXT_EVENT_STREAM_VALUE)으로 설정해야 올바르게 sse가 동작하게 됩니다.
겟 매핑의 주소는 제가 미리 설정해둔 슬래쉬 커넥트로 설정해주시면 됩니다.
매핑할 메소드의 리턴 타입은 리스폰스 엔티티로(ResponseEntity) 안에는 에스에스이 이미터를 넣어주시면 됩니다.
메소드의 입력 파라미터에는 유저의 이름과 게시글의 아이디를 받을 수 있도록 설정해주어야합니다.

다음으로 코멘트 서비스의 스타트 뷰잉 아티클 메소드를 호출하여 커넥션 인스턴스를 리턴받습니다.
마지막으로 리스폰스 엔티티에 커넥션의 이미터를 꺼태서 넣어주시고 리턴문을 작성해주면 컨트롤러 코드는 끝나게 됩니다.

본격적으로 서비스 코드를 작성해 보겟습니다.
커멘트 서비스로 이동해서 스타트 뷰잉 아티클 메소드를 작성할 차례입니다.
여기서는 3가지 기능을 작성해도록 하겠습니다.
먼저 탭과 연결된 커넥션이 있다면, 이를 만료시키는 기능을 작성하고
두번재는 새로운 커넥션을 가져오고 연결하는 기능을 작성하겠습니다.
마지막으로 커넥션 매니저를 이용하여 2가지 커넥션 연관 관계 컨테이너를 업데이트 하겠습니다.
2가지 커넥션 연관 관계 컨테이너는 탭 투 커넥션, 아티클 투 커넥션으로 이 둘 모두 쓰레드 세이프하게 접근하여야 합니다.
따라서 앞으로 작성하게될 뷰잉 아티클 메소드에는 신크로나이즈 키워드를 붙혀야 합니다.
동시성 제어 로직이 추가되는 이유는 커넥션 매니저에서 커넥션에 콜백을 추가하기 때문인데요
이 콜백은 다른 쓰레드에서 실행되고, 지금 작성하고 있는 스타트 뷰잉 아티클 메소드에서도 해당 자원에 접근하고 있기 때문에 동시성 제어를 추가해주어야 합니다.

이제 커넥션 매니저에서 컴플리트 올드 커넥션을 호출합니다. 이때 파라미터로 유저 아이디를 넘겨줍니다.
커넥션 매니저에서 겟 뉴 커넥션 메소드를 호출하여 새로운 커넥션을 받습니다. 이때 파라미터로 유저 아이디와 게시글 아이디를 넘겨줍니다.
커넥션 클래스에서는 자동으로 타임아웃 시간을 5분 재요청은 3초마다 전송하게 설정하게 됩니다.
이렇게 설정한 이유는 유저의 체류시간과 맞춰주었기 때문입니다.
타임아웃이 너무 길면 서버에서 불필요한 커넥션을 관리해주어야 하는 오버헤드가 증가하게 되구요
타임아웃이 너무 짧으면 불필요한 재연결 요청이 증가하게 되는 단점이 있어 이 둘의 트레이드 오프를 고려하여야 합니다.

에스에스이 연결 수립을 위해 새로운 커네션의 커넥트 메소드를 호출합니다.
이제 새로운 커넥션과 탭 그리고 게시물의 연관 관계를 저장하기 위해 커넥션 매니저의 업데이트 탭 투 커넥션과 업데이트 아티클 투 커넥션을 각각 호출합니다.
마지막으로 생성된 커넥션을 리턴하면 끝입니다.

작성한 연결 수립 과정이 올바르게 동작하는지 브라우저를 이용해 확인해보겠습니다
브라우저는 크롬을 켜서 개발자 도구를 열어 연결 과정을 확인해보겠습니다
주소창에 로컬호스트 팔공팔공을 입력하면, 미리 작성해둔 에이취티엠엘(html) 파일을 받을 수 있습니다
유저 이름을 입력하고, 알림 요청을 전송하면 개발자 도구에 타입이 이벤트 소스 응답은 200을 확인하실 수 있습니다

[두번째 시나리오, 댓글 전송 및 수신]
다음으로 두번째 시나리오인 알림된 게시글에 다른 유저가 작성한 댓글이 원래 유저에게 새로고침없이 보여주는 기능을 작성해보도록 하겠습니다.
이번에도 마찬가지로 컨트롤러의 세이브 코멘트 메소드를 먼저 작성해보도록 하겠습니다.
메소드의 입력 파라미터로는 댓글, 유저 이름, 게시글 아이디를 입력받아야 합니다.
포스트 매핑의 경로는 제가 미리 설정해둔 슬래쉬 코멘트로 해주시면 되겠습니다.
리턴 타입은 리스폰스 엔티티에 void를 넣어 주시고, 리턴문은 리스폰스 엔티티의 오케이 그리고 빌드 메소드를 연달아 호출해주시면 되겟습니다.
리턴문 바로 위에는 코멘트 서비스의 세이브 앤 샌드 메소드를 호출해주시면 끝입니다.

이제 본격적으로 코멘트 서비스의 세이브 앤 샌드 메소드를 작성해보도록 하겟습니다.
핸즈온 패키지의 코멘트 서비스로 이동하시겠습니다.

코드 작성에 앞서 여기서 구현하게될 기능들에 대해 간략히 소개시켜 드리겠습니다.
먼저 전달받은 댓글을 저장하는 기능을 작성하고
아티클과 연결된 커넥션들을 가져와서, 전달받은 댓글을 전송하는 기능을 구현해보도록 하겠습니다.

이전과 마찬가지로 세이브 앤 샌드 메소드에는 신크로나이즈 키워드를 붙혀주고, 입력 파라미터로 코멘트, 유저 아이디, 게시글 아이디를 받도록 하겠습니다.
전달받은 댓글을 저장하기 위해 아티클 투 코멘트 매니저의 업데이트 코멘트 메소드를 호출하여 주세요. 지금은 메모리에 댓글을 저장하고 있지만, 실전이었더라면 디비에 저장하는 부분이 바로 여기입니다.
자기 자신과 연결된 커넥션을 가져오기 위해, 커넥션 매니저의 겟 셀프 커넥션 메소드를 호출하여 주세요.
다음으로 게시글과 연결된 커넥션을 모두 가져오기 위해, 커넥션 매니저의 겟 커넥션 메소드를 호출하여 주세요.
마지막으로 셋에 담긴 커넥션에 스트림 포 이취(foreach) 커넥션 화살표 커넥션 쩜 센드 코멘트 메소드를 호출하여 주세요
이때 자기 자신을 제외시키기 위해 필터 체인을 추가해 주시고 느낌표 커넥션 쩜 이퀄스를 호출하여 셀프 커넥션과 비교해주세요
이렇게 세이브 앤 샌드 메소드 작성을 완료했습니다.

커넥션의 샌드 코멘트 메소드 안으로 들어 자세한 구현을 확인하실 수 있는데요
스프링의 에스에스이 이벤트 빌더를 이용하여 쉽게 이벤트를 구현하실 수 있습니다.

작성한 댓글 송신 수신 기능이 올바르게 동작하는지 브라우저를 이용해 확인해 보겠습니다.
먼저 스프링 어플리케이션을 실행 시키고, 크롬 브라우저의 탭을 2개 띄워주세요
2개의 탭 모두 개발자 도구를 열고 네트워크 탭에 접속해주세요
다음으로 2개 탭 모두 로컬 호스트 팔공팔공으로 접속해주세요
첫번째 탭에서는 foo라는 유저 이름으로 알림 요청을 전송하고, 2번째 탭에서는 bar라는 유저 이름으로 알림 요청을 전송해 주세요
foo라는 유저가 댓글을 달면 bar라는 유저의 브라우저에 새로운 댓글이 새로고침없이 전달되는지 확인해보겠습니다
보시는것과 같이 잘 전송된 모습을 확인하실 수 있습니다
또한 네트워크 탭에서 에스에스이의 특이한 점 중 하나인 커넥션이 일직선으로 쭉 연결되는 모습도 확인하실 수 있습니다.

이제 실습을 마치고 발표로 돌아가보겠습니다

9장, 정리

발표에 소개된 내용을 정리해보겠습니다.

첫째 SSE는 콜백을 등록하고, 이는 다른 쓰레드에서 실행되기 때문에, 동시성 문제를 주의해야 합니다.
SSE 생성시 등록하는 컴플리트, 에러 등의 콜백은 다른 쓰레드에서 실행되기 때문에,
해당 메소드에서 접근하는 자료구조는 반드시 쓰레드 세이프해야 합니다.

두번째 타임아웃 등 시간 설정을 주의해야합니다.
타임아웃은 5분, 브라우저의 실제 타임아웃 시간을 고려하여 만료 시간은 5분 1초로 설정해야 합니다.
타임아웃이 너무 길면 서버에서 커넥션을 관리 오버헤드가 증가하고,
타임아웃이 짧으면 바로바로 만료시킬 수 있지만, 재연결 요청이 증가하게됩니다.

세번째 SSE는 탭 당 연결되므로 만약 유저가 다른 탭에서 동일한 게시글을 보는 경우
해당 게시글에 대한 푸시가 유저에게 2번 전송될 수 있습니다.
이와 같은 케이스를 주의해서 설계해야 사용성을 향상시킬 수 있습니다.

그럼 이상으로 발표 마치겠습니다 감사합니다.

8장, 질의 응답

네 이것으로 발표는 모두 마무리 되었는데요 질문이 있으신가요?


### 추가할 내용 / 장표

[ ] 실습할 내용을 동영상으로 짧게 보여주면 이해가 쉬울듯
[x] 댓글에 탭아이디를 넣어서 보내주자(이때 탭 아이디는 사람 이름처럼...)
[x] 기술 비교할때 테이블 써보자
[ ] 실습할 코드도 미리 스니펫으로 보여주자

캐시 비워주는거 언급해야하나? o