1장, 제목

발표 시작하겠습니다.

안녕하세요 모두의 SSE 발표를 진행하는 김태훈입니다.
저는 아래 닉네임으로 활동하고 있습니다.

2장, 어떤걸 할 수 있나요, 누구에게 유용한가요

SSE는 서버에서 클라이언트 단방향으로 요청없이 데이터를 전송할 수 있습니다.
서버에서 데이터를 전송하는 특징을 이용해, 실시간 전송이 필요한 기능들을 구현할 수 있습니다.

따라서 댓글을 전송하거나, 알림 발송, 주식 차트 등을 구현해야하는 상황에서 유용합니다.

3장, 왜 굳이 SSE여야 하나요

실시간 데이터 전송을 지원하는 전통적인 방법 2가지 폴링, 롱 폴링에 대해 가볍게 알아보고,
웹소켓, 서비스 워커 등과 SSE를 비교해보겠습니다.

먼저 폴링은 클라이언트에서 일정 주기로, 요청을 전송하여 실시간으로 서버의 데이터를 받아오는 방식이고,
롱 폴링은 클라이언트가 요청을 보내면 응답 데이터가 있을때까지 지연시켰다가 응답하는 방식입니다.

웹소켓, sse 등은 전통적인 폴링, 롱 폴링과 달리 클라이언트의 요청없이 서버에서 데이터를 바로 전송하기 때문에 더 효율적입니다. 

이어어서 웹소켓에 대해 알아보겠습니다.
웹소켓은 처음에는 http를 이용하지만, 이후에는 자체 프로토콜을 이용합니다.
때문에 http의 캐싱이나 압축등과 같은 이점을 활용하지 못하는 단점이 있습니다.

다음으로 서비스 워커는, 생명주기 등이 복잡하여 처음 도입하기에는 망설여집니다.
몇몇 브라우저의 경우, 푸쉬가 발생하면 반드시 사용자에게 이를 표시해야하는 제약이 있습니다.
만약에 사용자에게 알리지 않고 백그라운드에서 필요한 작업인 경우, 적합하지 않을 수 있습니다.

SSE는, http를 그대로 사용할 수 있고, 백그라운드 작업은 물론 sse를 지원하는 기술들이 이미 마련되어 있는 장점이 있습니다.

4장, 스프링에서 SSE를 서포팅하는 기술

스프링 mvc 패키지와 webflux에서 SSE를 지원하고 있습니다.
이 중 에스에스이 이미터(SseEmitter)를 이용해 서버 센트 이벤트를 구현할 수 있습니다.

5장, 실습 순서

실습은 이해를 돕기위해 시나리오 설명, 구성품 소개, 실습 순으로 진행하겠습니다.

6장, 실습 시나리오 -1 설명

본격적으로 실습을 진행하기 전에, 실습에서 시연하게 될 시나리오에 대해 설명드리도록 하겠습니다.
첫번째 시나리오는 특정 게시글에 유저가 알림 요청을 전송하는 것입니다. 이를 통해 SSE 연결이 수립되었는지 확인하겠습니다.

7장, 실습 시나리오 -2 설명
두번째 시나리오는 해당 게시글에 다른 유저가 댓글 작성하게 되면, 이전에 알림 요청한 유저에게 새로고침없이 새로운 댓글이 보여지는게되는 시나리오입니다.

8장, 실습 준비

다음으로 레포지토리 안의 코드에 대해 설명드리도록 하겠습니다.
레포지토리를 클론하시면 루트 디렉토리 안에는 핸즈온 패키지와 프레퍼레이션 패키지 2가지가 보이게 됩니다.
이 중 프레퍼레이션 패키지는 제가 미리 준비해둔 패키지이고, 핸즈온 패키지안의 2개의 클래스는 함께 실습을 진행하며 만들어갈 파일입니다.

다음으로 편의를 위해 미리 작성된 프레페레이션 패키지 안의 코드에 대해 설명드리도록 하겠습니다.
코멘트 클래스는 게시글에 달리는 댓글입니다. 댓글은 쉬운 구현을 위해 작성자나, 제목과 같은 내용은 제거했고, 댓글 내용만 담고 있습니다.
인덱스 컨트롤러는 에이취티엠엘(html) 파일을 받기 위한 컨트롤러입니다. 에이취티엠엘(html)과 자바스크립트(js) 코드는 미리 작성해두었습니다.

마지막으로 핸즈온 패키지에 대해 설명드리겠습니다.
핸즈온 패키지 안의 2개 클래스 파일은 이번 실습을 통해 완성하게 될 파일입니다.
코멘트 컨트롤러에서는 SSE 연결 요청과 댓글 전송 요청을 매핑하는 코드를 작성하겠습니다.
코멘트 서비스에서는 각각의 시나리오에 대한 로직을 완성시켜나갈 메인 코드입니다.

다음으로 실습 진행하도록 하겠습니다.

9장, 실습

[첫번째 시나리오, 알림 요청]
첫번째 시나리오인 알림 요청 전송 기능을 작성해보도록 하겠습니다.
먼저 유저가 게시글에 알림을 걸 수 있도록 컨트롤러의 커넥트 메소드를 작성해보겠습니다.
메서드의 이름은 커넥트로 퍼블릭 커넥트로 작성해주시고 리턴 타입은 보이드로 설정해 주세요.
겟 매핑의 주소는 제가 미리 설정해둔 슬래쉬 커넥트로 설정해주시면 됩니다.
이때 프로듀스(produces) 값도 필요한데요 이 값은 텍스트 이벤트 스트림(TEXT_EVENT_STREAM_VALUE)으로 설정해야 올바르게 sse가 동작하게 됩니다.

이번에는 매핑할 메소드의 리턴 타입을 수정해보겠습니다.
리턴 타입은 리스폰스 엔티티로(ResponseEntity) 안에는 에스에스이 이미터를 넣어주시면 됩니다.
메소드의 입력 파라미터에는 게시글의 아이디를 받을 수 있도록 설정해주어야합니다.

다음으로 코멘트 서비스의 스타트 뷰잉 아티클 메소드를 호출하여 에스에스이 이미터를 인스턴스를 리턴받습니다.
마지막으로 리스폰스 엔티티에 이미터를 넣어주시고 리턴문을 작성해주면 컨트롤러 코드는 끝나게 됩니다.

본격적으로 서비스 코드를 작성해보도록 하겟습니다.
커멘트 서비스로 이동해서 스타트 뷰잉 아티클 메소드를 작성할 차례입니다.
빨강색으로 표시된 메소드에 단축키를 이용해서 메소드를 만들어 주세요.

여기서는 4가지 기능을 작성해도록 하겠습니다.
먼저 에스에스이 이미터를 생성하겠습니다.
두번재로 전송할 이벤트를 작성하겠습니다.
세번재로 작성한 이벤트를 전송하겠습니다.
네번째로 아티클과 연결된 이미터 컨테이너에 새로 생성한 이미터를 추가하겠습니다.

이제 첫번째 기능인 에스에스이 이미터를 생성해보겠습니다
뉴 키워드를 이용해 이미터를 생성해주세요. 이때 타임아웃값을 밀리세컨드 단위로 설정할 수 있습니다.
이번 실습에서는 가상으로 설정한 유저의 체류 시간과 동일하게 5분으로 설정하겠습니다.
5분은 30만입니다(300,000)
이렇게 설정한 이유는 가상으로 설정한 유저의 체류시간과 맞춰주었기 때문입니다.
타임아웃이 너무 길면 서버에서 불필요한 커넥션을 관리해주어야 하는 오버헤드가 증가하게 되구요
타임아웃이 너무 짧으면 불필요한 재연결 요청이 증가하게 되는 단점이 있어 이 둘의 트레이드 오프를 고려하여야 합니다.


두번째 기능인 전송할 이벤트를 작성해보겠습니다.
이벤트는 스프링의 에스에스이 이벤트 빌더를 이용하여 쉽게 이벤트를 구현하실 수 있습니다.
에스에스이 이미터 클래스의 이벤트 메소드에 네임, 데이터, 리커넥트타임 메소드를 체이님 해주세요
이벤트 이름은 connect로 설정해주시고, 데이터는 임의로 설정해주시면 됩니다.
이때 재요청 시간은 너무 짧지 않게 3초로 설정하겠습니다.
저는 단축키를 이용해 이 메소드의 리턴을 바로 받도록 하겠습니다.

이제 세번째 기능인 이벤트를 전송하는 코드를 작성하겠습니다.
이미터의 send 메소드를 호출하면 되는데, 익셉션이 발생할 수 있어 잡아주어야 합니다.
그럼 여기서는 어떤 에러가 발생할 수 있을까요?
SSE는 클라이언트의 연결 상태를 명시적으로 알 수 없기 때문에 다음과 같은 상황을 가정해볼 수 있을것 같습니다
어떤 유저 A가 댓글을 전송했는데, 때마침 동시에 해당 게시글을 보고 있던 유저 B가 탭을 닫은 상황입니다.
올바른 순서로 상황이 진행되었더라면, 닫은 탭과 연결된 이미터는 만료가 되었겠지만, 이와같은 상황에서는 그렇지 못해서 익셉션이 발생할 수 있습니다.
만약 서버에서 이를 만료시킬 수 있다면, 충분히 복구 가능한 케이스겠죠(?)
따라서 익셉션이 발생했다면, 이미터를 서버에서 만료시켜주야합니다. 캐치 블록에서 이미터의 컴플리트 메소드를 호출시켜줍시다.
그럼 이미터의 컴플리트 메소드는, 저희는 등록하지 않았지만, 이전에 등록해둔 콜백을 실행시키는데요, 그렇다면 이 콜백은 누가 실행시키는 걸까요? 
바로 전혀 다른 쓰레드에서 해당 콜백을 실행시키게 됩니다. 따라서 콜백에서 접근하게 되는 자원들은 반드시 쓰레드 세이프해야 하는점에 주의해주세요.
이 부분은 조금 복잡하니 메소드로 따로 빼두면 유용하니 추출해두겠습니다. 이때 파라미터로는 이벤트 빌더와 에스에스이 이미터를 넘겨주면 좋겠습니다.

이제 이벤트를 전송하는 코드를 완성했습니다.
다음으로 네번째 기능인 이미터 컨테이너에 새로 생성한 이미터를 추가하는 기능을 작성해보도록 하겠습니다.
먼저 이미터 컨테이너를 인스턴스 변수로 코멘트 서비스에 추가해보겠습니다.
뉴 컨커런트 해쉬맵을 이용해 생성해주세요 이름은 아티클 투 커넥션으로 설정해주세요
그리고 키에는 스트링, 벨류에는 셋을 넣어주시고 셋안에는 에스에스이 이미터를 추가해주세요
컨커런트 해쉬맵으로 컨테이너를 관리하는 이유는 여기서는 시간상 구현하지 않았지만, 보통은 타임아웃 콜백에서 타임아웃된 이미터를 제거해주기 때문에
다른 쓰레드에서 접근할 수 있는 컨테이너는 쓰레드 세이프한 자료구조를 선택하기 때문입니다.

이제 컨테이너에서 아티클 아이디를 이용해 이미터 셋을 꺼내오겠습니다. 겟 오얼 디폴트 메소드를 이용해 이미터 셋을 꺼내주세요
이제 생성한 이미터를 셋에 넣고, 이 셋을 다시 컨테이너에 풋해주면 새로운 이미터가 컨테이너에 저장되게 됩니다.
마지막으로 생성한 이미터를 리턴해주시면 끝입니다.

작성한 연결 수립 과정이 올바르게 동작하는지 브라우저를 이용해 확인해보겠습니다
브라우저는 크롬을 켜서 개발자 도구를 열어 연결 과정을 확인해보겠습니다
주소창에 로컬호스트 팔공팔공을 입력하면, 미리 작성해둔 에이취티엠엘(html) 파일을 받을 수 있습니다
유저 이름을 입력하고, 알림 요청을 전송하면 개발자 도구에 타입이 이벤트 소스 응답은 200을 확인하실 수 있습니다
또한 네트워크 탭에서 에스에스이의 특이한 점 중 하나인 커넥션이 일직선으로 쭉 연결되는 모습도 확인하실 수 있습니다.

[두번째 시나리오, 댓글 전송]
다음으로 두번째 시나리오인 알림된 게시글에 다른 유저가 작성한 댓글이 원래 유저에게 새로고침없이 보여주는 기능을 작성해보도록 하겠습니다.
이번에도 마찬가지로 컨트롤러의 세이브 코멘트 메소드를 먼저 작성해보도록 하겠습니다.
메소드의 입력 파라미터로는 댓글, 게시글 아이디를 입력받아야 합니다.
포스트 매핑의 경로는 제가 미리 설정해둔 슬래쉬 코멘트로 해주시면 되겠습니다.
메소드 이름은 savecomment로 해주시고 리턴 타입은 리스폰스 엔티티에 void를 넣어 주세요
리턴문은 리스폰스 엔티티의 오케이 그리고 빌드 메소드를 연달아 호출해주시면 되겟습니다.
리턴문 바로 위에는 코멘트 서비스의 세이브 앤 샌드 메소드에 코멘트와 아티클 아이디를 입력 파라미터로 넘겨서 호출해주시면 끝입니다.

이제 본격적으로 코멘트 서비스의 세이브 앤 샌드 메소드를 작성해보도록 하겟습니다.
핸즈온 패키지의 코멘트 서비스로 이동하시겠습니다.
저는 바로 빨강색으로 표시된 메소드에 단축키를 이용해서 메소드를 만들겠습니다

이제 세이브 앤 샌드 메소드에서는 크게 2가지 기능을 구현해보겠습니다
첫번째로 아트클과 연결된 이미터들을 가져오는 기능을 구현하고,
두번째로 전송할 이벤트를 작성하겠습니다.
세번재로 연결된 모든 이미터들에게 생성한 이벤트를 전송하는 기능을 구현해보도록 하겟습니다.

첫번재 기능인 아티클과 연결된 이미터들을 모두 가져오는 기능을 구현하기 위해
이전에 작성했던 컨테이너, 아티클 투 커넥션의 겟 오얼 디폴트 메소드를 호출해 주세요

다음으로 두번째 기능인 이벤트를 작성해보도록 하겠습니다
에스에스이 이미터 클래스의 이벤트 메소드에 네임, 데이터, 리커넥트타임 메소드를 체이닝 해주세요
이벤트 이름은 newComment로 설정해주시고, 데이터는 코멘트 인스턴스로 설정해주시면 됩니다.
이때 재요청 시간은 동일하게 3초로 설정하겠습니다.
저는 단축키를 이용해 이 메소드의 리턴을 바로 받도록 하겠습니다.

이제 세번째 기능인 연결된 모든 이미터들에게 이벤트를 전송하는 기능을 작성해보도록 하겠습니다
셋에 담긴 이미터들에서 닷 스트림 메소드를 호출하고 여기에 (포이취)foreeach 메소드를 체이닝해주세요.
(포이취)foreeach 안에서 커넥션 화살표를 작성해주시고, 이전에 작성한 샌드 메소드에 파라미터로 이벤트 빌더와 커넥션을 넘겨주세요

이제 작성한 댓글 송신 수신 기능이 올바르게 동작하는지 브라우저를 이용해 확인해 보겠습니다.
먼저 스프링 어플리케이션을 실행 시키고, 크롬 브라우저의 탭을 2개 띄워주세요
2개의 탭 모두 개발자 도구를 열고 네트워크 탭에 접속해주세요
다음으로 2개 탭 모두 로컬 호스트 팔공팔공으로 접속해주세요
첫번째 탭, 2번째 탭에서 알림 요청을 전송해 주세요
첫번째 탭에서 댓글을 달면 두번째 탭에서 새로운 댓글이 새로고침없이 전달되는지 확인해보겠습니다
보시는것과 같이 잘 전송된 모습을 확인하실 수 있습니다

이제 실습을 마치고 발표로 돌아가보겠습니다

10장, 정리

발표에 소개된 내용을 정리해보겠습니다.

첫째 SSE는 콜백을 등록하고, 이는 다른 쓰레드에서 실행되기 때문에, 동시성 문제를 주의해야 합니다.
SSE 생성시 등록하는 컴플리트, 에러 등의 콜백은 다른 쓰레드에서 실행되기 때문에,
해당 메소드에서 접근하는 자료구조는 반드시 쓰레드 세이프해야 합니다.

두번째 타임아웃 등 시간 설정을 주의해야합니다.
타임아웃은 5분, 브라우저의 실제 타임아웃 시간을 고려하여 만료 시간은 5분 1초로 설정해야 합니다.
타임아웃이 너무 길면 서버에서 커넥션을 관리 오버헤드가 증가하고,
타임아웃이 짧으면 바로바로 만료시킬 수 있지만, 재연결 요청이 증가하게됩니다.

세번째 SSE는 탭 당 연결되므로 만약 유저가 다른 탭에서 동일한 게시글을 보는 경우
해당 게시글에 대한 푸시가 유저에게 2번 전송될 수 있습니다.
이와 같은 케이스를 주의해서 설계해야 사용성을 향상시킬 수 있습니다.

그럼 이상으로 발표 마치겠습니다 감사합니다.

11장, 질의 응답

네 이것으로 발표는 모두 마무리 되었는데요 질문이 있으신가요?
